-- This file contains tests for Fast Query Shipping (FQS) for queries involving
-- a single table
-- Testset 1 for distributed table (by roundrobin)
select create_table_nodes('tab1_rr(val int, val2 int)', '{1, 2, 3}'::int[], 'roundrobin', NULL);
 create_table_nodes 
--------------------
 
(1 row)

insert into tab1_rr values (1, 2);
insert into tab1_rr values (2, 4);
insert into tab1_rr values (5, 3);
insert into tab1_rr values (7, 8);
insert into tab1_rr values (9, 2);
explain (verbose on, nodes off, num_nodes on, costs off) insert into tab1_rr values (9, 2);
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   ->  Insert on public.tab1_rr
         ->  Remote Subquery Scan on local node
               Output: 9, 2
               Distribute results by N
               ->  Result
                     Output: 9, 2
(7 rows)

-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
   ->  Seq Scan on public.tab1_rr
         Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
         Filter: (tab1_rr.val2 = 4)
(5 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_rr;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_rr;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.sum((sum(val))), pg_catalog.avg((avg(val))), pg_catalog.count(*)
   ->  Remote Subquery Scan on all
         Output: sum(val), avg(val), count(*)
         ->  Aggregate
               Output: sum(val), avg(val), count(*)
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
(8 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_rr;
ERROR:  Window functions are not supported yet
explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_rr;
ERROR:  Window functions are not supported yet
-- should not get FQSed because of LIMIT clause
select * from tab1_rr where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val2 = 3 limit 1;
                   QUERY PLAN                   
------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
                     Filter: (tab1_rr.val2 = 3)
(9 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_rr where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val2 = 4 offset 1;
                   QUERY PLAN                   
------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
                     Filter: (tab1_rr.val2 = 4)
(9 rows)

-- should not get FQSed because of SORT clause
select * from tab1_rr order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (verbose on, nodes off, costs off) select * from tab1_rr order by val;
               QUERY PLAN               
----------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_rr.val
         ->  Seq Scan on public.tab1_rr
               Output: val, val2
(7 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_rr where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_rr where val2 = 8;
                   QUERY PLAN                   
------------------------------------------------
 HashAggregate
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  HashAggregate
               Output: val, val2
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
                     Filter: (tab1_rr.val2 = 8)
(9 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_rr where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select val, val2 from tab1_rr where val2 = 8 group by val, val2;
                   QUERY PLAN                   
------------------------------------------------
 HashAggregate
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  HashAggregate
               Output: val, val2
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
                     Filter: (tab1_rr.val2 = 8)
(9 rows)

-- should not get FQSed because of HAVING clause
select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (verbose on, nodes off, costs off) select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
                     QUERY PLAN                     
----------------------------------------------------
 GroupAggregate
   Output: pg_catalog.sum((sum(val))), val2
   Filter: (pg_catalog.sum((sum(tab1_rr.val))) > 1)
   ->  Remote Subquery Scan on all
         Output: sum(val), val2
         ->  GroupAggregate
               Output: sum(val), val2
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
                     Filter: (tab1_rr.val2 = 2)
(10 rows)

-- tests for node reduction by application of quals, for roundrobin node
-- reduction is not applicable. Having query not FQSed because of existence of ORDER BY,
-- implies that nodes did not get reduced.
select * from tab1_rr where val = 7;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7;
            QUERY PLAN             
-----------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_rr
         Output: val, val2
         Filter: (tab1_rr.val = 7)
(5 rows)

select * from tab1_rr where val = 7 or val = 2 order by val;
 val | val2 
-----+------
   2 |    4
   7 |    8
(2 rows)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7 or val = 2 order by val;
                           QUERY PLAN                           
----------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_rr.val
         ->  Seq Scan on public.tab1_rr
               Output: val, val2
               Filter: ((tab1_rr.val = 7) OR (tab1_rr.val = 2))
(8 rows)

select * from tab1_rr where val = 7 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7 and val2 = 8 order by val;
                         QUERY PLAN                         
------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_rr
         Output: val, val2
         Filter: ((tab1_rr.val = 7) AND (tab1_rr.val2 = 8))
(5 rows)

select * from tab1_rr where val = 3 + 4 and val2 = 8 order by val;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 3 + 4 order by val;
            QUERY PLAN             
-----------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_rr
         Output: val, val2
         Filter: (tab1_rr.val = 7)
(5 rows)

select * from tab1_rr where val = char_length('len')+4 order by val;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_rr where val = char_length('len')+4 order by val;
            QUERY PLAN             
-----------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_rr
         Output: val, val2
         Filter: (tab1_rr.val = 7)
(5 rows)

-- insert some more values 
insert into tab1_rr values (7, 2); 
select avg(val) from tab1_rr where val = 7;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (verbose on, nodes off, costs off) select avg(val) from tab1_rr where val = 7;
                  QUERY PLAN                   
-----------------------------------------------
 Aggregate
   Output: pg_catalog.avg((avg(val)))
   ->  Remote Subquery Scan on all
         Output: avg(val)
         ->  Aggregate
               Output: avg(val)
               ->  Seq Scan on public.tab1_rr
                     Output: val, val2
                     Filter: (tab1_rr.val = 7)
(9 rows)

select val, val2 from tab1_rr where val = 7 order by val2;
 val | val2 
-----+------
   7 |    2
   7 |    8
(2 rows)

explain (verbose on, nodes off, costs off) select val, val2 from tab1_rr where val = 7 order by val2;
               QUERY PLAN                
-----------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_rr.val2
         ->  Seq Scan on public.tab1_rr
               Output: val, val2
               Filter: (tab1_rr.val = 7)
(8 rows)

select distinct val2 from tab1_rr where val = 7;
 val2 
------
    8
    2
(2 rows)

explain (verbose on, nodes off, costs off) select distinct val2 from tab1_rr where val = 7;
                  QUERY PLAN                   
-----------------------------------------------
 HashAggregate
   Output: val2
   ->  Remote Subquery Scan on all
         Output: val2
         ->  HashAggregate
               Output: val2
               ->  Seq Scan on public.tab1_rr
                     Output: val2
                     Filter: (tab1_rr.val = 7)
(9 rows)

-- DMLs
update tab1_rr set val2 = 1000 where val = 7; 
explain (verbose on, nodes off, costs off) update tab1_rr set val2 = 1000 where val = 7; 
                       QUERY PLAN                       
--------------------------------------------------------
 Remote Subquery Scan on all
   ->  Update on public.tab1_rr
         ->  Seq Scan on public.tab1_rr
               Output: val, 1000, val, ctid, xc_node_id
               Filter: (tab1_rr.val = 7)
(5 rows)

select * from tab1_rr where val = 7;
 val | val2 
-----+------
   7 | 1000
   7 | 1000
(2 rows)

delete from tab1_rr where val = 7; 
explain verbose delete from tab1_rr where val = 7; 
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Remote Subquery Scan on all (d01)  (cost=0.00..36.75 rows=11 width=14)
   ->  Delete on public.tab1_rr  (cost=0.00..36.75 rows=11 width=14)
         ->  Seq Scan on public.tab1_rr  (cost=0.00..36.75 rows=11 width=14)
               Output: val, ctid, xc_node_id
               Filter: (tab1_rr.val = 7)
(5 rows)

select * from tab1_rr where val = 7;
 val | val2 
-----+------
(0 rows)

-- Testset 2 for distributed tables (by hash)
select cr_table('tab1_hash(val int, val2 int)', '{1, 2, 3}'::int[], 'hash(val)');
 cr_table 
----------
 
(1 row)

insert into tab1_hash values (1, 2);
insert into tab1_hash values (2, 4);
insert into tab1_hash values (5, 3);
insert into tab1_hash values (7, 8);
insert into tab1_hash values (9, 2);
explain verbose insert into tab1_hash values (9, 2);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Remote Subquery Scan on all (d01)  (cost=0.00..0.01 rows=1 width=0)
   ->  Insert on public.tab1_hash  (cost=0.00..0.01 rows=1 width=0)
         ->  Remote Subquery Scan on local node  (cost=0.00..0.01 rows=1 width=0)
               Output: 9, 2
               Distribute results by H: 9
               ->  Result  (cost=0.00..0.01 rows=1 width=0)
                     Output: 9, 2
(7 rows)

-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 2;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
   ->  Seq Scan on public.tab1_hash
         Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
         Filter: (tab1_hash.val2 = 2)
(5 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_hash;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_hash;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.sum((sum(val))), pg_catalog.avg((avg(val))), pg_catalog.count(*)
   ->  Remote Subquery Scan on all
         Output: sum(val), avg(val), count(*)
         ->  Aggregate
               Output: sum(val), avg(val), count(*)
               ->  Seq Scan on public.tab1_hash
                     Output: val, val2
(8 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_hash;
ERROR:  Window functions are not supported yet
explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_hash;
ERROR:  Window functions are not supported yet
-- should not get FQSed because of LIMIT clause
select * from tab1_hash where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_hash where val2 = 3 limit 1;
                    QUERY PLAN                    
--------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_hash
                     Output: val, val2
                     Filter: (tab1_hash.val2 = 3)
(9 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_hash where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (verbose on, nodes off, costs off) select * from tab1_hash where val2 = 4 offset 1;
                    QUERY PLAN                    
--------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_hash
                     Output: val, val2
                     Filter: (tab1_hash.val2 = 4)
(9 rows)

-- should not get FQSed because of SORT clause
select * from tab1_hash order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (verbose on, nodes off, costs off) select * from tab1_hash order by val;
                QUERY PLAN                
------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_hash.val
         ->  Seq Scan on public.tab1_hash
               Output: val, val2
(7 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_hash where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_hash where val2 = 8;
                 QUERY PLAN                 
--------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  HashAggregate
         Output: val, val2
         ->  Seq Scan on public.tab1_hash
               Output: val, val2
               Filter: (tab1_hash.val2 = 8)
(7 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_hash where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select val, val2 from tab1_hash where val2 = 8 group by val, val2;
                 QUERY PLAN                 
--------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  HashAggregate
         Output: val, val2
         ->  Seq Scan on public.tab1_hash
               Output: val, val2
               Filter: (tab1_hash.val2 = 8)
(7 rows)

-- should not get FQSed because of HAVING clause
select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (verbose on, nodes off, costs off) select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
                      QUERY PLAN                      
------------------------------------------------------
 GroupAggregate
   Output: pg_catalog.sum((sum(val))), val2
   Filter: (pg_catalog.sum((sum(tab1_hash.val))) > 1)
   ->  Remote Subquery Scan on all
         Output: sum(val), val2
         ->  GroupAggregate
               Output: sum(val), val2
               ->  Seq Scan on public.tab1_hash
                     Output: val, val2
                     Filter: (tab1_hash.val2 = 2)
(10 rows)

-- tests for node reduction by application of quals. Having query FQSed because of
-- existence of ORDER BY, implies that nodes got reduced.
select * from tab1_hash where val = 7;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 7;
             QUERY PLAN              
-------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_hash
         Output: val, val2
         Filter: (tab1_hash.val = 7)
(5 rows)

select * from tab1_hash where val = 7 or val = 2 order by val;
 val | val2 
-----+------
   2 |    4
   7 |    8
(2 rows)

explain (verbose on, nodes off, costs off) select * from tab1_hash where val = 7 or val = 2 order by val;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_hash.val
         ->  Seq Scan on public.tab1_hash
               Output: val, val2
               Filter: ((tab1_hash.val = 7) OR (tab1_hash.val = 2))
(8 rows)

select * from tab1_hash where val = 7 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 7 and val2 = 8;
                           QUERY PLAN                           
----------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_hash
         Output: val, val2
         Filter: ((tab1_hash.val = 7) AND (tab1_hash.val2 = 8))
(5 rows)

select * from tab1_hash where val = 3 + 4 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 3 + 4;
             QUERY PLAN              
-------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_hash
         Output: val, val2
         Filter: (tab1_hash.val = 7)
(5 rows)

select * from tab1_hash where val = char_length('len')+4;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = char_length('len')+4;
             QUERY PLAN              
-------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_hash
         Output: val, val2
         Filter: (tab1_hash.val = 7)
(5 rows)

-- insert some more values 
insert into tab1_hash values (7, 2); 
select avg(val) from tab1_hash where val = 7;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select avg(val) from tab1_hash where val = 7;
                   QUERY PLAN                    
-------------------------------------------------
 Aggregate
   Output: pg_catalog.avg((avg(val)))
   ->  Remote Subquery Scan on all
         Output: avg(val)
         ->  Aggregate
               Output: avg(val)
               ->  Seq Scan on public.tab1_hash
                     Output: val, val2
                     Filter: (tab1_hash.val = 7)
(9 rows)

select val, val2 from tab1_hash where val = 7 order by val2;
 val | val2 
-----+------
   7 |    2
   7 |    8
(2 rows)

explain (verbose on, nodes off, costs off, num_nodes on) select val, val2 from tab1_hash where val = 7 order by val2;
                QUERY PLAN                 
-------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_hash.val2
         ->  Seq Scan on public.tab1_hash
               Output: val, val2
               Filter: (tab1_hash.val = 7)
(8 rows)

select distinct val2 from tab1_hash where val = 7;
 val2 
------
    8
    2
(2 rows)

explain (verbose on, nodes off, costs off, num_nodes on) select distinct val2 from tab1_hash where val = 7;
                   QUERY PLAN                    
-------------------------------------------------
 HashAggregate
   Output: val2
   ->  Remote Subquery Scan on all
         Output: val2
         ->  HashAggregate
               Output: val2
               ->  Seq Scan on public.tab1_hash
                     Output: val2
                     Filter: (tab1_hash.val = 7)
(9 rows)

-- DMLs
update tab1_hash set val2 = 1000 where val = 7; 
explain (verbose on, nodes off, costs off) update tab1_hash set val2 = 1000 where val = 7; 
                       QUERY PLAN                       
--------------------------------------------------------
 Remote Subquery Scan on all
   ->  Update on public.tab1_hash
         ->  Seq Scan on public.tab1_hash
               Output: val, 1000, val, ctid, xc_node_id
               Filter: (tab1_hash.val = 7)
(5 rows)

select * from tab1_hash where val = 7;
 val | val2 
-----+------
   7 | 1000
   7 | 1000
(2 rows)

delete from tab1_hash where val = 7; 
explain verbose delete from tab1_hash where val = 7; 
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Remote Subquery Scan on all (d01)  (cost=0.00..36.75 rows=11 width=14)
   ->  Delete on public.tab1_hash  (cost=0.00..36.75 rows=11 width=14)
         ->  Seq Scan on public.tab1_hash  (cost=0.00..36.75 rows=11 width=14)
               Output: val, ctid, xc_node_id, val
               Filter: (tab1_hash.val = 7)
(5 rows)

select * from tab1_hash where val = 7;
 val | val2 
-----+------
(0 rows)

-- Testset 3 for distributed tables (by modulo)
select cr_table('tab1_modulo(val int, val2 int)', '{1, 2, 3}'::int[], 'modulo(val)');
 cr_table 
----------
 
(1 row)

insert into tab1_modulo values (1, 2);
insert into tab1_modulo values (2, 4);
insert into tab1_modulo values (5, 3);
insert into tab1_modulo values (7, 8);
insert into tab1_modulo values (9, 2);
explain verbose insert into tab1_modulo values (9, 2);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Remote Subquery Scan on all (d01)  (cost=0.00..0.01 rows=1 width=0)
   ->  Insert on public.tab1_modulo  (cost=0.00..0.01 rows=1 width=0)
         ->  Remote Subquery Scan on local node  (cost=0.00..0.01 rows=1 width=0)
               Output: 9, 2
               Distribute results by M: 9
               ->  Result  (cost=0.00..0.01 rows=1 width=0)
                     Output: 9, 2
(7 rows)

-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
   ->  Seq Scan on public.tab1_modulo
         Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
         Filter: (tab1_modulo.val2 = 4)
(5 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_modulo;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_modulo;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.sum((sum(val))), pg_catalog.avg((avg(val))), pg_catalog.count(*)
   ->  Remote Subquery Scan on all
         Output: sum(val), avg(val), count(*)
         ->  Aggregate
               Output: sum(val), avg(val), count(*)
               ->  Seq Scan on public.tab1_modulo
                     Output: val, val2
(8 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_modulo;
ERROR:  Window functions are not supported yet
explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_modulo;
ERROR:  Window functions are not supported yet
-- should not get FQSed because of LIMIT clause
select * from tab1_modulo where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (verbose on, nodes off, costs off) select * from tab1_modulo where val2 = 3 limit 1;
                     QUERY PLAN                     
----------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_modulo
                     Output: val, val2
                     Filter: (tab1_modulo.val2 = 3)
(9 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_modulo where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (verbose on, nodes off, costs off) select * from tab1_modulo where val2 = 4 offset 1;
                     QUERY PLAN                     
----------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_modulo
                     Output: val, val2
                     Filter: (tab1_modulo.val2 = 4)
(9 rows)

-- should not get FQSed because of SORT clause
select * from tab1_modulo order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (verbose on, nodes off, costs off) select * from tab1_modulo order by val;
                 QUERY PLAN                 
--------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_modulo.val
         ->  Seq Scan on public.tab1_modulo
               Output: val, val2
(7 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_modulo where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_modulo where val2 = 8;
                  QUERY PLAN                  
----------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  HashAggregate
         Output: val, val2
         ->  Seq Scan on public.tab1_modulo
               Output: val, val2
               Filter: (tab1_modulo.val2 = 8)
(7 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off) select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
                  QUERY PLAN                  
----------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  HashAggregate
         Output: val, val2
         ->  Seq Scan on public.tab1_modulo
               Output: val, val2
               Filter: (tab1_modulo.val2 = 8)
(7 rows)

-- should not get FQSed because of HAVING clause
select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (verbose on, nodes off, costs off) select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
                       QUERY PLAN                       
--------------------------------------------------------
 GroupAggregate
   Output: pg_catalog.sum((sum(val))), val2
   Filter: (pg_catalog.sum((sum(tab1_modulo.val))) > 1)
   ->  Remote Subquery Scan on all
         Output: sum(val), val2
         ->  GroupAggregate
               Output: sum(val), val2
               ->  Seq Scan on public.tab1_modulo
                     Output: val, val2
                     Filter: (tab1_modulo.val2 = 2)
(10 rows)

-- tests for node reduction by application of quals. Having query FQSed because of
-- existence of ORDER BY, implies that nodes got reduced.
select * from tab1_modulo where val = 7;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 7;
              QUERY PLAN               
---------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_modulo
         Output: val, val2
         Filter: (tab1_modulo.val = 7)
(5 rows)

select * from tab1_modulo where val = 7 or val = 2 order by val;
 val | val2 
-----+------
   2 |    4
   7 |    8
(2 rows)

explain (verbose on, nodes off, costs off) select * from tab1_modulo where val = 7 or val = 2 order by val;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_modulo.val
         ->  Seq Scan on public.tab1_modulo
               Output: val, val2
               Filter: ((tab1_modulo.val = 7) OR (tab1_modulo.val = 2))
(8 rows)

select * from tab1_modulo where val = 7 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 7 and val2 = 8;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_modulo
         Output: val, val2
         Filter: ((tab1_modulo.val = 7) AND (tab1_modulo.val2 = 8))
(5 rows)

select * from tab1_modulo where val = 3 + 4 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 3 + 4;
              QUERY PLAN               
---------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_modulo
         Output: val, val2
         Filter: (tab1_modulo.val = 7)
(5 rows)

select * from tab1_modulo where val = char_length('len')+4;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = char_length('len')+4;
              QUERY PLAN               
---------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_modulo
         Output: val, val2
         Filter: (tab1_modulo.val = 7)
(5 rows)

-- insert some more values 
insert into tab1_modulo values (7, 2); 
select avg(val) from tab1_modulo where val = 7;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (verbose on, nodes off, costs off, num_nodes on) select avg(val) from tab1_modulo where val = 7;
                    QUERY PLAN                     
---------------------------------------------------
 Aggregate
   Output: pg_catalog.avg((avg(val)))
   ->  Remote Subquery Scan on all
         Output: avg(val)
         ->  Aggregate
               Output: avg(val)
               ->  Seq Scan on public.tab1_modulo
                     Output: val, val2
                     Filter: (tab1_modulo.val = 7)
(9 rows)

select val, val2 from tab1_modulo where val = 7 order by val2;
 val | val2 
-----+------
   7 |    2
   7 |    8
(2 rows)

explain (verbose on, nodes off, costs off, num_nodes on) select val, val2 from tab1_modulo where val = 7 order by val2;
                 QUERY PLAN                  
---------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_modulo.val2
         ->  Seq Scan on public.tab1_modulo
               Output: val, val2
               Filter: (tab1_modulo.val = 7)
(8 rows)

select distinct val2 from tab1_modulo where val = 7;
 val2 
------
    8
    2
(2 rows)

explain (verbose on, nodes off, costs off, num_nodes on) select distinct val2 from tab1_modulo where val = 7;
                    QUERY PLAN                     
---------------------------------------------------
 HashAggregate
   Output: val2
   ->  Remote Subquery Scan on all
         Output: val2
         ->  HashAggregate
               Output: val2
               ->  Seq Scan on public.tab1_modulo
                     Output: val2
                     Filter: (tab1_modulo.val = 7)
(9 rows)

-- DMLs
update tab1_modulo set val2 = 1000 where val = 7; 
explain (verbose on, nodes off, costs off) update tab1_modulo set val2 = 1000 where val = 7; 
                       QUERY PLAN                       
--------------------------------------------------------
 Remote Subquery Scan on all
   ->  Update on public.tab1_modulo
         ->  Seq Scan on public.tab1_modulo
               Output: val, 1000, val, ctid, xc_node_id
               Filter: (tab1_modulo.val = 7)
(5 rows)

select * from tab1_modulo where val = 7;
 val | val2 
-----+------
   7 | 1000
   7 | 1000
(2 rows)

delete from tab1_modulo where val = 7; 
explain verbose delete from tab1_modulo where val = 7; 
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Remote Subquery Scan on all (d01)  (cost=0.00..36.75 rows=11 width=14)
   ->  Delete on public.tab1_modulo  (cost=0.00..36.75 rows=11 width=14)
         ->  Seq Scan on public.tab1_modulo  (cost=0.00..36.75 rows=11 width=14)
               Output: val, ctid, xc_node_id, val
               Filter: (tab1_modulo.val = 7)
(5 rows)

select * from tab1_modulo where val = 7;
 val | val2 
-----+------
(0 rows)

-- Testset 4 for replicated tables, for replicated tables, unless the expression
-- is itself unshippable, any query involving a single replicated table is shippable
select cr_table('tab1_replicated(val int, val2 int)', '{1, 2, 3}'::int[], 'replication');
 cr_table 
----------
 
(1 row)

insert into tab1_replicated values (1, 2);
insert into tab1_replicated values (2, 4);
insert into tab1_replicated values (5, 3);
insert into tab1_replicated values (7, 8);
insert into tab1_replicated values (9, 2);
explain (verbose on, nodes off, costs off) insert into tab1_replicated values (9, 2);
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   ->  Insert on public.tab1_replicated
         ->  Remote Subquery Scan on local node
               Output: 9, 2
               Distribute results by R
               ->  Result
                     Output: 9, 2
(7 rows)

-- simple select
select * from tab1_replicated;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select * from tab1_replicated;
                QUERY PLAN                
------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Seq Scan on public.tab1_replicated
         Output: val, val2
(4 rows)

select sum(val), avg(val), count(*) from tab1_replicated;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (num_nodes on, verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_replicated;
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   Output: sum(val), avg(val), count(*)
   ->  Aggregate
         Output: sum(val), avg(val), count(*)
         ->  Seq Scan on public.tab1_replicated
               Output: val, val2
(6 rows)

select first_value(val) over (partition by val2 order by val) from tab1_replicated;
ERROR:  Window functions are not supported yet
explain (num_nodes on, verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_replicated;
ERROR:  Window functions are not supported yet
select * from tab1_replicated where val2 = 2 limit 2;
 val | val2 
-----+------
   1 |    2
   9 |    2
(2 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select * from tab1_replicated where val2 = 2 limit 2;
                       QUERY PLAN                       
--------------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_replicated
                     Output: val, val2
                     Filter: (tab1_replicated.val2 = 2)
(9 rows)

select * from tab1_replicated where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select * from tab1_replicated where val2 = 4 offset 1;
                       QUERY PLAN                       
--------------------------------------------------------
 Limit
   Output: val, val2
   ->  Remote Subquery Scan on all
         Output: val, val2
         ->  Limit
               Output: val, val2
               ->  Seq Scan on public.tab1_replicated
                     Output: val, val2
                     Filter: (tab1_replicated.val2 = 4)
(9 rows)

select * from tab1_replicated order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select * from tab1_replicated order by val;
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  Sort
         Output: val, val2
         Sort Key: tab1_replicated.val
         ->  Seq Scan on public.tab1_replicated
               Output: val, val2
(7 rows)

select distinct val, val2 from tab1_replicated;
 val | val2 
-----+------
   9 |    2
   5 |    3
   1 |    2
   2 |    4
   7 |    8
(5 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select distinct val, val2 from tab1_replicated;
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  HashAggregate
         Output: val, val2
         ->  Seq Scan on public.tab1_replicated
               Output: val, val2
(6 rows)

select val, val2 from tab1_replicated group by val, val2;
 val | val2 
-----+------
   9 |    2
   5 |    3
   1 |    2
   2 |    4
   7 |    8
(5 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select val, val2 from tab1_replicated group by val, val2;
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   Output: val, val2
   ->  HashAggregate
         Output: val, val2
         ->  Seq Scan on public.tab1_replicated
               Output: val, val2
(6 rows)

select sum(val) from tab1_replicated group by val2 having sum(val) > 1;
 sum 
-----
   7
   2
   5
  10
(4 rows)

explain (num_nodes on, verbose on, nodes off, costs off) select sum(val) from tab1_replicated group by val2 having sum(val) > 1;
                   QUERY PLAN                   
------------------------------------------------
 Remote Subquery Scan on all
   Output: sum(val), val2
   ->  HashAggregate
         Output: sum(val), val2
         Filter: (sum(tab1_replicated.val) > 1)
         ->  Seq Scan on public.tab1_replicated
               Output: val, val2
(7 rows)

-- DMLs
update tab1_replicated set val2 = 1000 where val = 7; 
explain (verbose on, nodes off, costs off) update tab1_replicated set val2 = 1000 where val = 7; 
                   QUERY PLAN                    
-------------------------------------------------
 Remote Subquery Scan on all
   ->  Update on public.tab1_replicated
         ->  Seq Scan on public.tab1_replicated
               Output: val, 1000, val, ctid
               Filter: (tab1_replicated.val = 7)
(5 rows)

select * from tab1_replicated where val = 7;
 val | val2 
-----+------
   7 | 1000
(1 row)

delete from tab1_replicated where val = 7; 
explain verbose delete from tab1_replicated where val = 7; 
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Remote Subquery Scan on all (d01)  (cost=0.00..36.75 rows=11 width=10)
   ->  Delete on public.tab1_replicated  (cost=0.00..36.75 rows=11 width=10)
         ->  Seq Scan on public.tab1_replicated  (cost=0.00..36.75 rows=11 width=10)
               Output: val, ctid
               Filter: (tab1_replicated.val = 7)
(5 rows)

select * from tab1_replicated where val = 7;
 val | val2 
-----+------
(0 rows)

drop table tab1_rr;
drop table tab1_hash;
drop table tab1_modulo;
drop table tab1_replicated;
drop function cr_table(varchar, int[], varchar); 
